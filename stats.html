<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Î™®Î∞îÎÖ∏Í∏∞ Ï†ÑÌà¨ Î¶¨Ìè¨Ìä∏</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background-color: #1c1c1c;
      color: #ecf0f1;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #ranking {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100%; /* üëà Íº≠ ÌïÑÏöî */
    }
    #ranking .toolbar {
      background: #2c3e50;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    #ranking.toolbar button {
      padding: 6px 12px;
      font-weight: bold;
      background: transparent;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #ranking .toolbar input[type="text"] {
      padding: 6px;
      border-radius: 4px;
      border: none;
    }
    #ranking .toolbar label {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #ranking .status {
      margin-left: auto;
      font-weight: bold;
    }
    #ranking .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #ranking .panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #ranking .summary-section, .log-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #ranking .summary-section h2, .log-section h2, .totals-section h2 {
      margin: 16px 20px 8px;
      color: #3498db;
    }
    #ranking .log-section .scroll-container {
      flex: 1;
      overflow-y: auto;
      padding: 0 20px 20px;
    }
    #ranking table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9em;
    }
    th, td {
      padding: 8px;
      text-align: center;
    }
    th {
      background-color: #34495e;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tr:nth-child(even) {
      background-color: #2c2c2c;
    }
    #damageMeter {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #1a1a1a;
      color: #ffffff;
      margin: 0;
      padding: 20px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    #damageMeter .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 20px;
    }
    #damageMeter .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    #damageMeter .header h1 {
        margin: 0;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #damageMeter .battle-info {
        display: flex;
        justify-content: space-around;
        margin-top: 15px;
        font-size: 1.1em;
    }

    #damageMeter .player-rankings {
        background-color: #2c2c2c;
        border-radius: 10px;
        padding: 20px 30px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    #damageMeter .ranking-header {
        display: grid;
        grid-template-columns: 60px 1fr 240px; /* Damage column width adjusted */
        gap: 15px;
        padding: 15px 20px;
        background-color: #34495e;
        border-radius: 8px;
        margin-bottom: 20px;
        font-weight: bold;
        font-size: 0.9em;
        color: #ecf0f1;
    }

    #damageMeter .ranking-header > div:last-child {
        text-align: right;
    }

    #damageMeter .player-bar {
        margin-bottom: 12px;
        position: relative;
        background-color: #4a4a4a;
        border-radius: 8px;
        overflow: visible;
        height: 50px;
        transition: all 0.3s ease;
        cursor: pointer;
    }

    #damageMeter .player-bar-content {
        display: grid;
        grid-template-columns: 60px 1fr 240px; /* Damage column width adjusted */
        gap: 15px;
        align-items: center;
        position: relative;
        z-index: 2;
        height: 100%;
        padding: 0 7px;
    }

    #damageMeter .player-bar:hover {
        transform: translateX(5px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    #damageMeter .rank-section {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 10px;
    }

    #damageMeter .rank-number {
        background-color: #34495e;
        color: #ecf0f1;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1em;
        font-weight: bold;
    }

    #damageMeter .rank-1 { background: linear-gradient(135deg, #f1c40f, #f39c12); color: #2c3e50; }
    #damageMeter .rank-2 { background: linear-gradient(135deg, #95a5a6, #bdc3c7); color: #2c3e50; }
    #damageMeter .rank-3 { background: linear-gradient(135deg, #e67e22, #d35400); color: white; }

    /* --- NEW: Stacked Bar Styles --- */
    #damageMeter .player-bar-fill-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        display: flex; /* Use flexbox for stacking */
        transition: width 0.5s ease;
        border-radius: 8px;
        z-index: 1;
        overflow: hidden; /* Hide overflow from child elements */
    }

    #damageMeter .damage-segment {
        height: 100%;
        transition: width 0.5s ease;
    }

    #damageMeter .other-targets-damage {
        /* Make "other" damage slightly transparent or darker */
        filter: brightness(0.7);
    }
    /* --- End of New Styles --- */

    #damageMeter .player-name {
        font-weight: bold;
        font-size: 1em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        color: #ffffff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding-left: 15px;
        display: flex;
        align-items: center;
    }

    #damageMeter .stat-value {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        font-weight: bold;
        font-size: 0.95em;
        text-align: right;
        padding: 0 5px;
        gap: 4px; /* Space between damage numbers and DPS */
    }

    #damageMeter .damage-value .plus-sign {
        color: #bdc3c7;
        font-weight: normal;
    }

    #damageMeter .damage-value .total-dps {
        color: #f39c12; /* Highlight DPS */
        font-weight: normal;
        margin-left: 5px;
    }

    #damageMeter .connection-status {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 15px;
        border-radius: 5px;
        font-weight: bold;
        z-index: 1000;
    }

    #damageMeter .connected {
        background-color: #27ae60;
        color: white;
    }

    #damageMeter .disconnected {
        background-color: #e74c3c;
        color: white;
    }

    #damageMeter .no-data {
        text-align: center;
        color: #7f8c8d;
        font-size: 1.2em;
        margin: 50px 0;
    }
    
    /* -- Skill Breakdown (mostly unchanged) -- */
    #damageMeter .skill-breakdown {
        background-color: #3a3a3a;
        border-radius: 8px;
        margin-top: 10px;
        padding: 15px;
        border-left: 4px solid #3498db;
        display: none;
    }

    #damageMeter .skill-breakdown.show {
        display: block;
    }

    #damageMeter .skill-breakdown.show.animate {
        animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
        from { opacity: 0; max-height: 0; padding-top: 0; padding-bottom: 0; }
        to { opacity: 1; max-height: 500px; padding-top: 15px; padding-bottom: 15px; }
    }

    #damageMeter .skill-breakdown-header {
        font-size: 1.1em;
        font-weight: bold;
        margin-bottom: 15px;
        color: #3498db;
    }

    #damageMeter .skill-item {
        margin-bottom: 8px;
        position: relative;
        background-color: #4a4a4a;
        border-radius: 4px;
        overflow: visible;
        height: 30px;
        display: flex;
        align-items: center;
    }

    #damageMeter .skill-item-fill {
        height: 100%;
        background: linear-gradient(90deg, #e74c3c, #c0392b);
        transition: width 0.3s ease;
        border-radius: 4px;
        position: relative;
    }

    #damageMeter .skill-item-info {
        position: absolute;
        left: 10px; top: 50%;
        transform: translateY(-50%);
        font-size: 0.85em; font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        z-index: 2; color: #ffffff;
    }

    #damageMeter .skill-item-stats {
        position: absolute;
        right: 10px; top: 50%;
        transform: translateY(-50%);
        font-size: 0.85em; font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        color: #ffffff; z-index: 3;
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 3px;
    }
  </style>
</head>
<body>
  <!-- ÌÉ≠ Î©îÎâ¥ -->
  <div id="tab-menu" style="margin-bottom: 10px;">
      <button onclick="showTab('ranking')" id="tab-ranking" class="tab-button active">Í∞úÏù∏ Î¶¨Ìè¨Ìä∏</button>
      <button onclick="showTab('damageMeter')" id="tab-meter" class="tab-button">ÎîúÎØ∏ÌÑ∞Í∏∞</button>
  </div>

  <div id="ranking" class="tab-content"  style="display:none;">
    <div class="toolbar">
      <h1 style="text-align: center; margin: 20px 0; color: #e67e22;">Î™®Î∞îÎÖ∏Í∏∞ Ï†ÑÌà¨ Î¶¨Ìè¨Ìä∏</h1>
      <button onclick="resetData()">Í∏∞Î°ù Ï¥àÍ∏∞Ìôî</button>
      <button onclick="exportCSV()">CSVÎ°ú Ï†ÄÏû•</button>
      <label><input type="checkbox" id="filter-dot" checked /> DOT Ï†úÏô∏</label>
      <label>Ïä§ÌÇ¨Î™Ö: <input type="text" id="skill-filter" placeholder="Ïä§ÌÇ¨ Ïù¥Î¶Ñ ÌïÑÌÑ∞" /></label>
      <label>ÌÉÄÍ≤ü: <input type="text" id="target-filter" placeholder="ÌÉÄÍ≤ü ÌïÑÌÑ∞" list="target-suggestions" />
        <button onclick="document.getElementById('target-filter').value=''; updateTables();">‚ùå</button>
      </label>
      <label>ÏÇ¨Ïö©Ïûê: <input type="text" id="user-filter" placeholder="ÏÇ¨Ïö©Ïûê ÌïÑÌÑ∞" list="user-suggestions" />
        <button onclick="document.getElementById('user-filter').value=''; updateTables();">‚ùå</button>
      </label>
      <label>ÏßÅÏóÖ: <span id="class-name"></span></label>
      <datalist id="target-suggestions"></datalist>
      <datalist id="user-suggestions"></datalist>
      <div class="status" id="ws-status">üî¥ Ïó∞Í≤∞ ÏïàÎê®</div>
    </div>
        <div class="main">
            <div class="panel">
                <div class="summary-section">
                <h2>Ïä§ÌÇ¨ ÌÜµÍ≥Ñ</h2>
                <div class="scroll-container">
                    <table id="summary-table">
                    <thead>
                        <tr>
                        <th>#</th>
                        <th>Ïä§ÌÇ¨</th>
                        <th>ÌöüÏàò</th>
                        <th>Ï¥ùÌï©</th>
                        <th>ÌèâÍ∑†</th>
                        <th>ÏµúÏÜå</th>
                        <th>ÏµúÎåÄ</th>
                        <th>ÏπòÎ™ÖÌÉÄ%</th>
                        <th>Ï∂îÍ∞ÄÌÉÄ%</th>
                        <th>Ï†êÏú†Ïú®</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                    </table>
                </div>
                </div>
            <div class="totals-section">
                <table>
                    <thead>
                    <tr>
                        <th>Ï¥ù Îç∞ÎØ∏ÏßÄ</th>
                        <th>Ï¥ù ÌûàÌä∏ Ïàò</th>
                        <th>ÌèâÍ∑† Îç∞ÎØ∏ÏßÄ</th>
                        <th>ÏπòÎ™ÖÌÉÄ Ïàò</th>
                        <th>ÏπòÎ™ÖÌÉÄ ÌôïÎ•†</th>
                        <th>Ï∂îÍ∞ÄÌÉÄ ÌôïÎ•†</th>
                    </tr>
                    </thead>
                    <tbody id="totals-table">
                    <tr>
                        <td id="total-damage">0</td>
                        <td id="total-hits">0</td>
                        <td id="avg-damage">0</td>
                        <td id="total-crits">0</td>
                        <td id="crit-rate">0%</td>
                        <td id="add-hit-rate">0%</td>
                    </tr>
                    </tbody>
                </table>
                </div>
            </div>      
            <div class="log-section">
                <h2>Îç∞ÎØ∏ÏßÄ Î°úÍ∑∏</h2>
                <div class="scroll-container">
                    <table id="log-table">
                    <thead>
                        <tr>
                        <th>ÏãúÍ∞Ñ</th>
                        <th>Ïä§ÌÇ¨</th>
                        <th>ÎåÄÏÉÅ</th>
                        <th>Îç∞ÎØ∏ÏßÄ</th>
                        <th>ÌÅ¨Î¶¨</th>
                        <th>Ïπ¥Ïö¥ÌÑ∞</th>
                        <th>Î¨¥Î∞©ÎπÑ</th>
                        <th>Ï∂îÍ∞ÄÌÉÄ</th>
                        <th>Ïó∞ÌÉÄ</th>
                        <th>Í∞ïÌÉÄ</th>
                        <th>ÏÉÅÌÉúÏù¥ÏÉÅ</th>
                        <th>ATK</th>
                        <th>SPD</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    
  </div>

  <div id="damageMeter" class="tab-content">
    <div class="container">
      <div class="header">
          <h1>üë• Î™®ÎπÑÎÖ∏Í∏∞ ÎØ∏ÌÑ∞Í∏∞ - ÌîåÎ†àÏù¥Ïñ¥ Îû≠ÌÇπ</h1>
          <div class="battle-info">
              <span>Ï†ÑÌà¨ ÏãúÍ∞Ñ: <span id="battle-time">0Ï¥à</span></span>
              <span>Ï¥ù Îç∞ÎØ∏ÏßÄ: <span id="total-damage1">0</span></span>
              <span>RDPS: <span id="raid-dps">0</span></span>
              <span>Ï∞∏Ïó¨ ÌîåÎ†àÏù¥Ïñ¥: <span id="player-count">0</span></span>
          </div>
      </div>

      <div class="connection-status disconnected" id="connection-status">
          Ïó∞Í≤∞ ÎÅäÍπÄ
      </div>

      <div class="player-rankings" id="player-rankings">
      </div>
    </div>
  </div>

  <script>
    const logTableBody = document.querySelector('#log-table tbody');
    const summaryTableBody = document.querySelector('#summary-table tbody');
    const targetDatalist = document.getElementById('target-suggestions');
    const userDatalist = document.getElementById('user-suggestions');
    const knownTargets = new Set();
    const knownUsers = new Set();
    const classMapping = {
        'Í≤ÄÏà†ÏÇ¨': { name: 'Í≤ÄÏà†', color: 'linear-gradient(90deg, #8B4513, #A0522D)' },
        'ÏÑùÍ∂ÅÏÇ¨Ïàò': { name: 'ÏÑùÍ∂ÅÏÇ¨Ïàò', color: 'linear-gradient(90deg, #228B22, #32CD32)' },
        'ÌôîÏóºÏà†ÏÇ¨': { name: 'ÌôîÎ≤ï', color: 'linear-gradient(90deg, #FF4500, #FF6347)' },
        'ÎπôÍ≤∞Ïà†ÏÇ¨': { name: 'ÏñºÌÉ±', color: 'linear-gradient(90deg, #4169E1, #87CEEB)' },
        'Ï†ÑÍ≤©Ïà†ÏÇ¨': { name: 'Ï†ÑÍ≤©Ïà†ÏÇ¨', color: 'linear-gradient(90deg, #8A2BE2, #9370DB)' },
        'Í≤©Ìà¨Í∞Ä': { name: 'Í≤©Ìà¨Í∞Ä', color: 'linear-gradient(90deg, #DC143C, #B22222)' },
        'Ïû•Í∂ÅÎ≥ë': { name: 'Ïû•Í∂ÅÎ≥ë', color: 'linear-gradient(90deg, #2E8B57, #3CB371)' },
        'ÌûêÎü¨': { name: 'ÌûêÎü¨', color: 'linear-gradient(90deg, #FFD700, #FFA500)' },
        'Ï†ÑÏÇ¨': { name: 'Ï†ÑÏÇ¨', color: 'linear-gradient(90deg, #696969, #808080)' },
        'ÎåÄÍ≤ÄÏ†ÑÏÇ¨': { name: 'ÎåÄÍ≤ÄÏ†ÑÏÇ¨', color: 'linear-gradient(90deg, #4B0082, #6A5ACD)' },
        'ÎèÑÏ†Å': { name: 'ÎèÑÏ†Å', color: 'linear-gradient(90deg, #2F4F4F, #708090)' },
        'ÎìÄÎ∏î': { name: 'ÎìÄÎ∏î', color: 'linear-gradient(90deg, #8B008B, #DA70D6)' },
        'Í∂ÅÏàò': { name: 'Í∂ÅÏàò', color: 'linear-gradient(90deg, #006400, #228B22)' },
        'ÎßàÎ≤ïÏÇ¨': { name: 'ÎßàÎ≤ïÏÇ¨', color: 'linear-gradient(90deg, #4B0082, #9400D3)' },
        'ÏÇ¨Ï†ú': { name: 'ÏÇ¨Ï†ú', color: 'linear-gradient(90deg, #F0F8FF, #E6E6FA)' },
        'ÏùåÏú†ÏãúÏù∏': { name: 'ÏùåÏú†ÏãúÏù∏', color: 'linear-gradient(90deg, #FF69B4, #FFB6C1)' },
        'ÏàòÎèÑÏÇ¨': { name: 'ÏàòÎèÑÏÇ¨', color: 'linear-gradient(90deg, #CD853F, #D2691E)' },
        'ÎåÑÏÑú': { name: 'ÎåÑÏÑú', color: 'linear-gradient(90deg, #FF1493, #FF69B4)' },
        'ÏïÖÏÇ¨': { name: 'ÏïÖÏÇ¨', color: 'linear-gradient(90deg, #9932CC, #BA55D3)' }
    };

    let battleData = {};
    let battleData1 = {};
    let startTime = 0;
    let lastUpdateTime = 0;
    let totalBattleDamage = 0;
    let expandedPlayers = new Set(); 
    let retryCount = 0;

    function init() {
        connectWebSocket();
        document.getElementById('filter-dot').addEventListener('change', updateTables);
        document.getElementById('skill-filter').addEventListener('input', updateTables);
        document.getElementById('target-filter').addEventListener('input', updateTables);
        document.getElementById('user-filter').addEventListener('input', updateTables);
    }

    function connectWebSocket() {
        try {
            const ws = new WebSocket('ws://192.168.219.109:8000');
        
            ws.onopen = function(event) {
                console.log('WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ');
                console.log('Open event: ', event);
                updateConnectionStatus('open');
                retryCount = 0;
            };
            ws.onclose = function(event) {
                console.log('WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
                console.log('Close event: ', event);
                updateConnectionStatus('close');
                if (retryCount < 5) {
                    retryCount++;
                    console.log(`Ïû¨ÏãúÎèÑ ${retryCount}Ìöå`);
                } else {
                    console.error('WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º');
                }
                setTimeout(connectWebSocket, 3000);
            };
            ws.onerror = function(event) {
                console.error('WebSocket Ïò§Î•ò Î∞úÏÉù');
                console.error('Error: ', event);
                updateConnectionStatus('error');
                if (retryCount < 5) {
                    retryCount++;
                    console.log(`Ïû¨ÏãúÎèÑ ${retryCount}Ìöå`);
                } else {
                    console.error('WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º');
                }
                setTimeout(connectWebSocket, 3000);
            };
            ws.onmessage = async (e) => {
                // e.dataÍ∞Ä BlobÏù¥Îùº Í∞ÄÏ†ïÌïòÍ≥† ArrayBufferÎ°ú Î≥ÄÌôò
                const buffer = await e.data.arrayBuffer();
                const view = new DataView(buffer);
                let offset = 0;

                while (offset + 2 <= buffer.byteLength) {
                    const length = view.getUint16(offset, true);  // 2Î∞îÏù¥Ìä∏ Í∏∏Ïù¥ (little endian)
                    offset += 2;

                    if (offset + length > buffer.byteLength) {
                        console.warn('Î∂àÏôÑÏ†ÑÌïú Î©îÏãúÏßÄ Í∞êÏßÄ, Ï≤òÎ¶¨ Ï§ëÎã®');
                        break;
                    }

                    const msgBytes = new Uint8Array(buffer, offset, length);
                    offset += length;

                    const packetBuffer = msgBytes.buffer.slice(msgBytes.byteOffset, msgBytes.byteOffset + length);
                    const data = unpackDamagePacket(packetBuffer);
                    processDamageData(data);
                }

                updateTables();
                updateDisplay();
            };
        
        } catch (error) {
            updateConnectionStatus('error');
            console.error('WebSocket Ïó∞Í≤∞ Ïã§Ìå®:', error);
            if (retryCount < 5) {
                retryCount++;
                console.log(`Ïû¨ÏãúÎèÑ ${retryCount}Ìöå`);
            } else {
                console.error('WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º');
            }
            setTimeout(connectWebSocket, 3000);
        }
    }
    
    function updateConnectionStatus(connected) {
        const wsStatus = document.getElementById('ws-status');
        const statusElement = document.getElementById('connection-status');
        if (connected == 'open') {
            wsStatus.textContent = 'üü¢ Ïó∞Í≤∞Îê®';
            statusElement.textContent = 'üü¢ Ïó∞Í≤∞Îê®';
            statusElement.className = 'connection-status connected';
        } else if (connected == 'close') {
            wsStatus.textContent = 'üî¥ Ïó∞Í≤∞ Ï¢ÖÎ£å';
            statusElement.textContent = 'üî¥ Ïó∞Í≤∞ Ï¢ÖÎ£å';
            statusElement.className = 'connection-status disconnected';
        } else if (connected == 'error') {
            wsStatus.textContent = 'üî¥ Ïò§Î•ò';
            statusElement.textContent = 'üî¥ Ïò§Î•ò';
            statusElement.className = 'connection-status disconnected';
        } else {
            wsStatus.textContent = 'üî¥ Ïó∞Í≤∞ ÏïàÎê®';
            statusElement.textContent = 'üî¥ Ïó∞Í≤∞ ÏïàÎê®';
            statusElement.className = 'connection-status disconnected';
        }
    }
    
    function updatePlayerClass(userData) {
            if (!userData.skills) return;
            let currentClassCode = null;
            for (const skillName of Object.keys(userData.skills)) {
                for (const [classCode, classInfo] of Object.entries(classMapping)) {
                    if (skillName.includes(classCode)) {
                        currentClassCode = classCode;
                    }
                }
                if(currentClassCode) {
                    break;
                }
            }
            document.getElementById('class-name').textContent = currentClassCode ? classMapping[currentClassCode].name : 'Unknown';
            return currentClassCode;
        }

    function resetData() {
        knownTargets.clear();
        knownUsers.clear();
        targetDatalist.innerHTML = '';
        userDatalist.innerHTML = '';
        battleData = {};
        logTableBody.innerHTML = '';
        summaryTableBody.innerHTML = '';
        document.getElementById('user-filter').value = '';
        document.getElementById('skill-filter').value = '';
        document.getElementById('class-name').textContent = '';
        document.getElementById('total-damage').textContent = 0;
        document.getElementById('total-hits').textContent = 0;
        document.getElementById('avg-damage').textContent = 0;
        document.getElementById('total-crits').textContent = 0;
        document.getElementById('crit-rate').textContent = '0%';
        document.getElementById('add-hit-rate').textContent = '0%';
    }
    
    function exportCSV() {
        const userFilter = document.getElementById('user-filter').value.toLowerCase();
        let allLogs = [];
        if(!userFilter) {
            allLogs = Object.values(battleData).flatMap(user => user.damageLogs);
        } else {
            const userData = battleData[userFilter];
            if (userData) {
                allLogs = userData.damageLogs;
            }
        }
        if (allLogs.length === 0) return;
        const header = Object.keys(allLogs[0]).join(',');
        const rows = allLogs.map(log => Object.values(log).join(','));
        const csvContent = [header, ...rows].join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'damage_logs.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function unpackDamagePacket(buffer) {
        const view = new DataView(buffer);
        let offset = 0;

        // 1. timestamp (uint64, little endian)
        const low = view.getUint32(offset, true);
        const high = view.getUint32(offset + 4, true);
        const timestamp = (BigInt(high) << 32n) | BigInt(low);
        offset += 8;

        // 2. used_by (4 bytes)
        const usedBy = [...new Uint8Array(buffer.slice(offset, offset + 4))]
            .map(b => b.toString(16).padStart(2, '0')).join('');
        offset += 4;

        // 3. target (4 bytes)
        const target = [...new Uint8Array(buffer.slice(offset, offset + 4))]
            .map(b => b.toString(16).padStart(2, '0')).join('');
        offset += 4;

        // 4. damage (uint32)
        const damage = view.getUint32(offset, true);
        offset += 4;

        // 5. flags1 (uint16)
        const flags1 = view.getUint16(offset, true);
        offset += 2;

        // üîç flags ÎîîÏΩîÎî©
        const critFlag      = (flags1 >> 0) & 1;
        const addHitFlag    = (flags1 >> 1) & 1;
        const unguardedFlag = (flags1 >> 2) & 1;
        const breakFlag     = (flags1 >> 3) & 1;
        const powerFlag     = (flags1 >> 4) & 1;
        const fastFlag      = (flags1 >> 5) & 1;
        const dotFlag       = (flags1 >> 6) & 0xF;  // 4ÎπÑÌä∏ (6~9ÎπÑÌä∏)

        // 6. atk (uint32)
        const atk = view.getUint32(offset, true);
        offset += 4;

        // 7. spd (float32)
        const spd = view.getFloat32(offset, true);
        offset += 4;

        // 8. skill_name length (uint8)
        const nameLen = view.getUint8(offset);
        offset += 1;

        // 9. skill_name (UTF-8)
        const skillBytes = new Uint8Array(buffer.slice(offset, offset + nameLen));
        const skillName = new TextDecoder('utf-8').decode(skillBytes);
        offset += nameLen;

        return {
            timestamp,
            used_by: usedBy,
            target,
            damage,
            crit_flag: critFlag,
            add_hit_flag: addHitFlag,
            unguarded_flag: unguardedFlag,
            break_flag: breakFlag,
            power_flag: powerFlag,
            fast_flag: fastFlag,
            dot_flag: dotFlag,
            atk,
            spd,
            skill_name: skillName
        };
    }


    function processDamageData(log) {
        console.log("Ï≤òÎ¶¨Îêú Î°úÍ∑∏:", log);

        const timestamp = parseInt(log.timestamp);
        const usedBy = log.used_by.toLowerCase();
        const target = log.target.toLowerCase();
        const skill = log.skill_name;
        const damage = parseInt(log.damage);
        const critFlag = parseInt(log.crit_flag);
        const addHitFlag = parseInt(log.add_hit_flag);

        if (lastUpdateTime === 0 || timestamp - lastUpdateTime > 10000) {
            startNewBattle(timestamp);
        }

        lastUpdateTime = timestamp;

        if (!battleData[usedBy]) {
            battleData[usedBy] = {
                totalDamage: 0,
                totalHits: 0,
                totalCrits: 0,
                hitCount: 0,
                critCount: 0,
                addHitCount: 0,
                damageLogs: [],
                damageByTarget: {},
                skills: {},
                atk: log.atk ?? 0,
                spd: log.spd ?? 0.0
            };
        } else {
            battleData[usedBy].atk = log.atk ?? battleData[usedBy].atk;
            battleData[usedBy].spd = log.spd ?? battleData[usedBy].spd;
        }

        updateTargetSuggestions(target);

        if (!battleData[usedBy].damageByTarget[target]) {
            battleData[usedBy].damageByTarget[target] = 0;
        }

        if (!battleData[usedBy].skills[log.skill_name]) {
            battleData[usedBy].skills[log.skill_name] = {
                damage: 0,
                hits: 0,
                crits: 0,
                addHits: 0
            };
        }

        battleData[usedBy].totalDamage += damage;
        battleData[usedBy].damageByTarget[target] += damage;
        battleData[usedBy].skills[skill].damage += damage;
        battleData[usedBy].damageLogs ??= [];
        battleData[usedBy].damageLogs.push(log);
        
        if (!addHitFlag) {
            battleData[usedBy].hitCount += 1;
            battleData[usedBy].skills[skill].hits += 1;
        }

        if (critFlag) {
            battleData[usedBy].critCount += 1;
            battleData[usedBy].skills[skill].crits += 1;
        }

        if (addHitFlag) {
            battleData[usedBy].addHitCount += 1;
            battleData[usedBy].skills[skill].addHits += 1;
        }

        totalBattleDamage += damage;

        updateUserSuggestions(usedBy);
    }

    function updateTargetSuggestions(target) {
      if (!knownTargets.has(target)) {
        knownTargets.add(target);
        const option = document.createElement('option');
        option.value = target;
        targetDatalist.appendChild(option);
      }
    }

    function updateUserSuggestions(user) {
        if (!knownUsers.has(user)) {
            knownUsers.add(user);
          
            // Ìï¥Îãπ ÏÇ¨Ïö©ÏûêÏùò ÏßÅÏóÖ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
            const userData = battleData[user];
            let className = '';
            if (userData){
                className = classMapping[updatePlayerClass(userData)] ? classMapping[updatePlayerClass(userData)].name : '';
            }
            const option = document.createElement('option');
            option.value = user;
            option.textContent = className ? `${user}(${className})` : user;
            userDatalist.appendChild(option);
        } else{
            // Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Í≤ΩÏö∞, ÏßÅÏóÖ Ï†ïÎ≥¥Í∞Ä ''Ïù¥Î©¥ ÏÉàÎ°úÏö¥ ÏßÅÏóÖ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            const existingOption = Array.from(userDatalist.options).find(opt => opt.textContent === user);
            if (existingOption) {
                const userData = battleData[user];
                let className = '';
                if (userData){
                    className = classMapping[updatePlayerClass(userData)] ? classMapping[updatePlayerClass(userData)].name : '';
                }
                existingOption.textContent = className ? `${user}(${className})` : user;
            }
        }
    }

    function startNewBattle(timestamp) {
        console.log("ÏÉàÎ°úÏö¥ Ï†ÑÌà¨ ÏãúÏûë");
        battleData = {};
        startTime = timestamp;
        totalBattleDamage = 0;
        expandedPlayers.clear();
        knownTargets.clear();
        knownUsers.clear();
        updateDisplay();
    }

    function updateTables() {
        const filterDot = document.getElementById('filter-dot').checked;
        const skillFilter = document.getElementById('skill-filter').value.toLowerCase();
        const targetFilter = document.getElementById('target-filter').value.toLowerCase();
        let userFilter = document.getElementById('user-filter').value.toLowerCase();
        let userData = {};
        let damageLogs = []
        if (!userFilter) {
            userData = { total: 0, hits: 0, crits: 0, addHits: 0, skills: {} };
            damageLogs = Object.values(battleData).flatMap(user => user.damageLogs);
            userFilter = '';
        } else {
            userData = Object.assign({}, battleData[userFilter]);
            if (!userData) {
                logTableBody.innerHTML = '<tr><td colspan="11">Ìï¥Îãπ ÏÇ¨Ïö©ÏûêÏùò Î°úÍ∑∏Í∞Ä ÏóÜÏäµÎãàÎã§.</td></tr>';
                summaryTableBody.innerHTML = '';
                return;
            }
            damageLogs = userData.damageLogs;
        }

        const filteredLogs = damageLogs.filter(log => {
            if (filterDot && log.dot_flag != 0) return false;
            if (skillFilter && !log.skill_name.toLowerCase().includes(skillFilter)) return false;
            if (targetFilter && !log.target.toLowerCase().includes(targetFilter)) return false;
            if (userFilter && !log.used_by.toLowerCase().includes(userFilter)) return false;
            return true;
        });
        userData.total = 0;
        userData.hits = 0;
        userData.crits = 0;
        userData.addHits = 0;
        userData.skills = {};
        filteredLogs.forEach(log => {
            const dmg = parseInt(log.damage);
            const name = log.skill_name;
            const isCrit = log.crit_flag === 1;
            const isAddHit = log.add_hit_flag === 1;

            if (!userData.skills[name]) {
                userData.skills[name] = { count: 0, total: 0, min: dmg, max: dmg, hits: 0, addHits:0, crits: 0 };
            }
            const stat = userData.skills[name];

            stat.min = Math.min(stat.min, dmg);
            stat.max = Math.max(stat.max, dmg);

            userData.total += dmg;
            stat.total += dmg;
            stat.count += 1;

            if(!isAddHit) {
                userData.hits += 1;
                stat.hits += 1;
            }
            if (isCrit) {
                userData.crits += 1;
                stat.crits += 1;
            }
            if (isAddHit) {
                userData.addHits += 1;
                stat.addHits += 1;
            }
        });
        updateTotals(userData);
        updatePlayerClass(userData);
        summaryTableBody.innerHTML = Object.entries(userData.skills)
            .sort(([, a], [, b]) => b.total - a.total)
            .map(([name, stat], idx) => {
            const avg = stat.total / stat.count;
            const pct = (stat.total / userData.total) * 100;
            const critRate = (stat.crits / stat.count * 100).toFixed(1);
            const addHitRate = (stat.addHits / stat.count * 100).toFixed(1);
            return `
                <tr>
                <td>${idx + 1}</td>
                <td>${name}</td>
                <td>${stat.count}</td>
                <td>${stat.total.toLocaleString()}</td>
                <td>${avg.toFixed(0)}</td>
                <td>${stat.min}</td>
                <td>${stat.max}</td>
                <td>${critRate}%</td>
                <td>${addHitRate}%</td>
                <td>${pct.toFixed(1)}%</td>
                </tr>`;
            }).join('');

        logTableBody.innerHTML = filteredLogs.map(log => {
            const now = new Date(parseInt(log.timestamp)).toLocaleTimeString('ko-KR');
            return `
            <tr>
                <td>${now}</td>
                <td>${log.skill_name}</td>
                <td>${log.target}</td>
                <td>${Number(log.damage).toLocaleString()}</td>
                <td>${log.crit_flag === 1 ? '‚úÖ' : ''}</td>
                <td>${log.unguarded_flag === 1 ? '‚úÖ' : ''}</td>
                <td>${log.break_flag === 1 ? '‚úÖ' : ''}</td>
                <td>${log.add_hit_flag === 1 ? '‚úÖ' : ''}</td>
                <td>${log.fast_flag === 1 ? '‚úÖ' : ''}</td>
                <td>${log.power_flag === 1 ? '‚úÖ' : ''}</td>
                <td>
                ${{
                    1: '‚ùÑÔ∏è',    // ice
                    2: 'üî•',    // fire
                    3: '‚ö°',    // electric
                    4: '‚úùÔ∏è',    // holy
                    5: 'ü©∏',    // bleed
                    6: 'üñ§',    // dark
                    7: '‚ò†Ô∏è',    // poison
                    8: 'üß†'     // mind
                }[log.dot_flag] ?? ''}
                </td>
                <td>${log.atk}</td>
                <td>${log.spd.toFixed(2)}</td>
            </tr>`;
        }).join('');
    }

    function updateTotals(userData) {
        document.getElementById('total-damage').textContent = userData.total.toLocaleString();
        document.getElementById('total-hits').textContent = userData.hits;
        document.getElementById('avg-damage').textContent = userData.hits > 0 ? Math.round(userData.total / userData.hits).toLocaleString() : 0;
        document.getElementById('total-crits').textContent = userData.crits;
        document.getElementById('crit-rate').textContent = userData.hits > 0 ? ((userData.crits / userData.hits) * 100).toFixed(1) + '%' : '0%';
        document.getElementById('add-hit-rate').textContent = userData.hits > 0 ? ((userData.addHits / userData.hits) * 100).toFixed(1) + '%' : '0%';
    }

    function updateDisplay() {
        updateBattleInfo();
        updatePlayerRankings();
    }

    function updateBattleInfo() {
        const battleTime = lastUpdateTime > 0 ? Math.floor((lastUpdateTime - startTime) / 1000) : 0;
        const playerCount = Object.values(battleData).filter(ud => updatePlayerClass(ud)).length;

        let raidDps = 0;
        if (battleTime > 0) {
            raidDps = Math.floor(totalBattleDamage / battleTime);
        }
        document.getElementById('battle-time').textContent = `${battleTime}Ï¥à`;
        document.getElementById('total-damage1').textContent = totalBattleDamage.toLocaleString();
        document.getElementById('raid-dps').textContent = raidDps.toLocaleString();
        document.getElementById('player-count').textContent = playerCount;
        
    }

    function updatePlayerRankings() {
        const container = document.getElementById('player-rankings');

        if (Object.keys(battleData).length === 0) {
            container.innerHTML = `<div class="ranking-header"><div>ÏàúÏúÑ</div><div>ÌîåÎ†àÏù¥Ïñ¥</div><div>Îç∞ÎØ∏ÏßÄ (Îã®Ïùº DPS)</div></div><div class="no-data">Îç∞ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Îã§Î¶¨Îäî Ï§ë...</div>`;
            return;
        }

        const sortedPlayers = Object.entries(battleData).sort(([,a], [,b]) => b.totalDamage - a.totalDamage);

        const maxDamage = sortedPlayers.length > 0 ? sortedPlayers[0][1].totalDamage : 1;
        const battleTime = lastUpdateTime > 0 ? Math.max(1, (lastUpdateTime - startTime) / 1000) : 1;

        let html = `<div class="ranking-header"><div>ÏàúÏúÑ</div><div>ÌîåÎ†àÏù¥Ïñ¥</div><div>Îç∞ÎØ∏ÏßÄ (Îã®Ïùº DPS)</div></div>`;

        let displayedPlayerIndex = 0;
        sortedPlayers.forEach(([userId, userData]) => {
            const detectedClass = updatePlayerClass(userData);
            if (!detectedClass || !classMapping[detectedClass]) {
                return; 
            }

            // --- NEW: Calculate damage split ---
            let mainTargetDamage = 0;
            let otherTargetsDamage = 0;

            const targetDamages = Object.values(userData.damageByTarget);
            if (targetDamages.length > 0) {
                mainTargetDamage = Math.max(...targetDamages);
            }
            otherTargetsDamage = userData.totalDamage - mainTargetDamage;
            
            const mainDamagePercentOfTotal = userData.totalDamage > 0 ? (mainTargetDamage / userData.totalDamage) * 100 : 0;
            const otherDamagePercentOfTotal = 100 - mainDamagePercentOfTotal;
            // --- End of new calculation ---

            const playerDps = Math.floor(mainTargetDamage / battleTime);
            const barWidth = (userData.totalDamage / maxDamage) * 100;
            const barColor = classMapping[detectedClass].color;
            const className = classMapping[detectedClass].name;
            const rankClass = displayedPlayerIndex < 3 ? `rank-${displayedPlayerIndex + 1}` : '';
            const displayName = `${className} ${userId.substring(0, 8)}`;

            html += `
                <div class="player-bar" onclick="toggleSkillBreakdown('${userId}')">
                    <div class="player-bar-fill-wrapper" style="width: ${barWidth}%;">
                        <div class="damage-segment main-target-damage" style="width: ${mainDamagePercentOfTotal}%; background: ${barColor};"></div>
                        <div class="damage-segment other-targets-damage" style="width: ${otherDamagePercentOfTotal}%; background: ${barColor};"></div>
                    </div>
                    <div class="player-bar-content">
                        <div class="rank-section">
                            <div class="rank-number ${rankClass}">${displayedPlayerIndex + 1}</div>
                        </div>
                        <div class="player-name">
                            ${displayName}
                        </div>
                        <div class="stat-value damage-value">
                            ${mainTargetDamage.toLocaleString()}
                            <span class="plus-sign">+</span>
                            ${otherTargetsDamage.toLocaleString()}
                            <span class="total-dps">(${playerDps.toLocaleString()})</span>
                        </div>
                    </div>
                </div>
                <div class="skill-breakdown ${expandedPlayers.has(userId) ? 'show' : ''}" id="skills-${userId}">
                    ${generateSkillBreakdown(userId, userData)}
                </div>
            `;
            
            displayedPlayerIndex++;
        });
        
        if (displayedPlayerIndex === 0) {
            html += `<div class="no-data">Í∞êÏßÄÎêú ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</div>`;
        }

        container.innerHTML = html;
    }

    function generateSkillBreakdown(userId, userData) {
        // This breakdown currently shows total skill damage across all targets.
        // A more advanced version might track skills per target.
        if (!userData.skills || Object.keys(userData.skills).length === 0) {
            return '<div style="color: #7f8c8d; text-align: center; padding: 20px;">Ïä§ÌÇ¨ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</div>';
        }

        const sortedSkills = Object.entries(userData.skills).sort(([,a], [,b]) => b.damage - a.damage);
        const maxSkillDamage = sortedSkills.length > 0 ? sortedSkills[0][1].damage : 1;

        let skillHtml = `<div class="skill-breakdown-header">Ïú†Ï†Ä ${userId.substring(0, 8)} - Ïä§ÌÇ¨ ÏÉÅÏÑ∏ (Ï†ÑÏ≤¥ ÌÉÄÍ≤ü Ìï©ÏÇ∞)</div>`;
        sortedSkills.forEach(([skillName, skillData]) => {
            const skillPercentage = userData.totalDamage > 0 ? ((skillData.damage / userData.totalDamage) * 100).toFixed(1) : 0;
            const skillTotalHits = skillData.hits + skillData.addHits;
            const skillCritRate = skillTotalHits > 0 ? ((skillData.crits / skillTotalHits) * 100).toFixed(1) : 0;
            const barWidth = (skillData.damage / maxSkillDamage) * 100;
            
            skillHtml += `
                <div class="skill-item">
                    <div class="skill-item-fill" style="width: ${barWidth}%">
                        <div class="skill-item-info">${skillName}</div>
                    </div>
                    <div class="skill-item-stats">
                        ÌÉÄÏàò ${skillData.hits} | ÌÅ¨Î¶¨ ${skillCritRate}% | Ï∂îÍ∞ÄÌÉÄÏú® ${skillData.hits > 0 ? ((skillData.addHits / skillData.hits) * 100).toFixed(1) : 0}% | 
                        ${(() => {
                            if (skillData.damage != null && typeof skillData.damage === 'number') {
                                return skillData.damage.toLocaleString();
                            } else {
                                console.warn('skillData.damageÍ∞Ä null ÎòêÎäî Ï†ïÏùòÎêòÏßÄ ÏïäÏùå:', skillData.damage);
                                return '0';
                            }
                        })()} (${skillPercentage}%)
                    </div>
                </div>
            `;
        });

        return skillHtml;
    }

    function toggleSkillBreakdown(userId) {
        const skillBreakdown = document.getElementById(`skills-${userId}`);
        if (!skillBreakdown) return;

        if (expandedPlayers.has(userId)) {
            expandedPlayers.delete(userId);
            skillBreakdown.classList.remove('show');
        } else {
            // Collapse others first for single-expansion mode
            document.querySelectorAll('.skill-breakdown.show').forEach(el => el.classList.remove('show'));
            expandedPlayers.clear();
            
            expandedPlayers.add(userId);
            // Update content before showing to ensure it's fresh
            const userData = battleData[userId];
            if (userData) {
                skillBreakdown.innerHTML = generateSkillBreakdown(userId, userData);
            }
            skillBreakdown.classList.add('show', 'animate');
            setTimeout(() => skillBreakdown.classList.remove('animate'), 300);
        }
    }
    
    function showTab(tabId) {
      document.querySelectorAll('.tab-content').forEach(div => {
        div.style.display = (div.id === tabId) ? 'block' : 'none';
      });
    }
  
    init();
  </script>
</body>
</html>
